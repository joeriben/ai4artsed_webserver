<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>AI4ArtsEd ‚Äì only API-compatible Workflows</title>
  <style>
    body { font-family: sans-serif; padding: 2rem; background: #f3f3f3; }
    .container { max-width: 800px; margin: auto; background: white; padding: 2rem; border-radius: 1rem; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
    input, select, button, textarea { display: block; width: 100%; margin: 1rem 0; padding: 0.5rem; font-size: 1rem; }
    button { background: #007bff; color: white; border: none; cursor: pointer; border-radius: 0.25rem; }
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    img { max-width: 100%; border-radius: 0.5rem; margin-top: 1rem; }
    #status { padding: 0.5rem; margin: 1rem 0; border-radius: 0.5rem; }
    .status-info { background: #e3f2fd; color: #1976d2; }
    .status-error { background: #ffebee; color: #c62828; }
    .status-success { background: #e8f5e9; color: #2e7d32; }
    .status-warning { background: #fff3e0; color: #e65100; }
    .controls-row { display: flex; gap: 1rem; margin: 1rem 0; }
    .control-group { flex: 1; }
    .control-group label { display: block; margin-bottom: 0.5rem; font-weight: bold; }
    .dimensions-display { font-size: 0.9rem; color: #666; margin-top: 0.3rem; font-style: italic; }
    .text-outputs { margin-top: 2rem; border-top: 1px solid #ddd; padding-top: 1rem; }
    .text-output-item { background: #f5f5f5; border: 1px solid #ddd; border-radius: 0.5rem; padding: 1rem; margin-bottom: 1rem; }
    .text-output-label { font-weight: bold; color: #555; margin-bottom: 0.5rem; }
    .text-output-content { white-space: pre-wrap; font-family: monospace; background: white; padding: 0.5rem; border-radius: 0.25rem; border: 1px solid #e0e0e0; }
    .progress-container { display: none; margin: 1rem 0; background: #f0f0f0; border-radius: 0.5rem; padding: 0.2rem; position: relative; }
    .progress-bar { height: 20px; background: #007bff; border-radius: 0.4rem; transition: width 0.3s ease; width: 0%; }
    .progress-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.9rem; font-weight: bold; color: #333; text-shadow: 0 0 3px white; }
    .progress-details { font-size: 0.85rem; color: #666; margin-top: 0.5rem; text-align: center; line-height: 1.4; }
  </style>
</head>
<body>
<div class="container">
  <h1>AI4ArtsEd</h1>

  <div id="status" class="status-info">Lade API-Workflows...</div>

  <label for="workflow">Workflows:</label>
  <select id="workflow">
    <option value="">-- Bitte w√§hlen --</option>
  </select>

  <label for="prompt">Prompt:</label>
  <textarea id="prompt" rows="4" placeholder="Beschreibe dein Bild oder gib Anweisungen...">Ein Banner mit der Aufschrift Default-Prompt</textarea>

  <div class="controls-row">
    <div class="control-group">
      <label for="size">Size ‚Äì Gr√∂√üe:</label>
      <select id="size" onchange="updateDimensions()">
        <option value="small">Small ‚Äì Klein (0.25 Megapixel)</option>
        <option value="large" selected>Big ‚Äì Gro√ü (1 Megapixel)</option>
      </select>
    </div>
    <div class="control-group">
      <label for="aspectRatio">Image Ratio ‚Äì Seitenverh√§ltnis:</label>
      <select id="aspectRatio" onchange="updateDimensions()">
        <option value="16:9">‚ñ≠ 16:9 landscape</option>
        <option value="3:2">‚ñ≠ 3:2 landscape</option>
        <option value="4:3">‚ñ≠ 4:3 landscape</option>
        <option value="5:4">‚ñ≠ 5:4 landscape</option>
        <option value="1:1" selected>‚ñ† 1:1 square</option>
        <option value="4:5">‚ñØ 4:5 portrait</option>
        <option value="3:4">‚ñØ 3:4 portrait</option>
        <option value="2:3">‚ñØ 2:3 portrait</option>
        <option value="9:16">‚ñØ 9:16 portrait</option>
      </select>
      <div id="dimensionsDisplay" class="dimensions-display"></div>
    </div>
  </div>

  <button id="submitBtn" onclick="submitPrompt()">Submit Prompt - Workflow ausf√ºhren</button>

  <div id="progressContainer" class="progress-container">
    <div id="progressBar" class="progress-bar"></div>
    <div id="progressText" class="progress-text">0%</div>
  </div>
  <div id="progressDetails" class="progress-details"></div>

  <img id="result" style="display: none;">

  <div id="textOutputs" class="text-outputs" style="display: none;">
    <h3>üìù Text-Outputs</h3>
    <div id="textOutputsContent"></div>
  </div>
</div>

<script>
const MAX_POLLING_TRIES = 180;
const POLLING_INTERVAL_MS = 1000;

let websocket = null;
let currentPromptId = null;
let totalNodes = 0;
let executedNodes = new Set();
let originalWorkflow = null;

// Berechne Dimensionen basierend auf Gr√∂√üe und Seitenverh√§ltnis
function calculateDimensions(size, aspectRatio) {
  const baseSize = size === 'small' ? 512 : 1024;
  const [wRatio, hRatio] = aspectRatio.split(':').map(Number);
  const totalPixels = baseSize * baseSize;
  const aspectValue = wRatio / hRatio;
  let width = Math.round(Math.sqrt(totalPixels * aspectValue));
  let height = Math.round(totalPixels / width);
  width = Math.round(width / 8) * 8;
  height = Math.round(height / 8) * 8;
  return { width, height };
}

function updateDimensions() {
  const size = document.getElementById('size').value;
  const aspectRatio = document.getElementById('aspectRatio').value;
  const dims = calculateDimensions(size, aspectRatio);
  document.getElementById('dimensionsDisplay').textContent =
    `Ausgabe: ${dims.width} √ó ${dims.height} Pixel`;
}

function setStatus(message, type='info') {
  const status = document.getElementById('status');
  status.textContent = message;
  status.className = `status-${type}`;
}

function updateProgress(progress, nodeInfo=null) {
  const progContainer = document.getElementById('progressContainer');
  const progBar = document.getElementById('progressBar');
  const progText = document.getElementById('progressText');
  const progDetails = document.getElementById('progressDetails');

  progContainer.style.display = 'block';
  progress = Math.min(progress, 100);
  progBar.style.width = `${progress}%`;
  progText.textContent = `${Math.round(progress)}%`;

  if (nodeInfo) {
    if (executedNodes.size > 0 && totalNodes > 0) {
      progDetails.innerHTML = `
        <div>${nodeInfo}</div>
        <div style="font-size: 0.8em; margin-top: 0.3em;">
          Fortschritt: ${executedNodes.size} von ${totalNodes} Nodes
        </div>
      `;
    } else {
      progDetails.textContent = nodeInfo;
    }
    progDetails.style.display = 'block';
  }
}

function hideProgress() {
  document.getElementById('progressContainer').style.display = 'none';
  document.getElementById('progressDetails').style.display = 'none';
}

// Z√§hlt alle ausf√ºhrbaren Nodes (alle class_type au√üer "Note" und "Reroute")
function countExecutableNodes(workflow) {
  let count = 0;
  for (const nodeId in workflow) {
    const node = workflow[nodeId];
    if (node.class_type !== 'Note' && node.class_type !== 'Reroute') {
      count += 1;
    }
  }
  return count;
}

function handleWebSocketMessage(event) {
  try {
    const message = JSON.parse(event.data);
    if (message.data?.prompt_id !== currentPromptId) return;

    switch (message.type) {
      case 'executing':
        const nodeId = message.data.node;
        executedNodes.add(nodeId);
        const node = originalWorkflow[nodeId];
        const title = node._meta?.title || node.class_type || `Node ${nodeId}`;
        const baseProg = (executedNodes.size / totalNodes) * 100;
        setStatus(`Verarbeite: ${title}`, 'info');
        updateProgress(baseProg, `Node ${executedNodes.size}/${totalNodes}: ${title}`);
        break;

      case 'progress':
        const stepProg = message.data.value / message.data.max;
        const nodeWeight = 1 / totalNodes;
        const base = ((executedNodes.size - 1) / totalNodes) * 100;
        const nodeProg = stepProg * nodeWeight * 100;
        const totalProg = base + nodeProg;
        updateProgress(totalProg, `Step ${message.data.value}/${message.data.max}`);
        break;

      case 'execution_cached':
        for (const cachedId of message.data.nodes) {
          executedNodes.add(cachedId);
        }
        const prog = (executedNodes.size / totalNodes) * 100;
        updateProgress(prog, `${message.data.nodes.length} Nodes aus Cache`);
        break;
    }
  } catch (e) {
    console.error('WebSocket Verarbeitungsfehler:', e);
  }
}

function setupWebSocket(clientId) {
  if (websocket) websocket.close();
  totalNodes = 0;
  executedNodes.clear();
  originalWorkflow && (totalNodes = countExecutableNodes(originalWorkflow));

  try {
    const proto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    websocket = new WebSocket(`${proto}//${window.location.host}/ws?clientId=${clientId}`);
    websocket.onmessage = handleWebSocketMessage;
    websocket.onerror = () => setStatus('WebSocket-Fehler', 'error');
    websocket.onclose = (evt) => {
      if (!evt.wasClean && executedNodes.size > 0 && executedNodes.size < totalNodes) {
        setStatus('Verbindung unterbrochen', 'error');
      }
    };
    const timeout = setTimeout(() => {
      if (websocket.readyState !== WebSocket.OPEN) {
        setStatus('Die Bearbeitung kann bis zu ca. 2,5 Minuten dauern', 'error');
        websocket.close();
      }
    }, 120000); // 2 Minuten gewartet

    websocket.onopen = () => clearTimeout(timeout);
  } catch (e) {
    console.error('WebSocket-Einrichtungsfehler:', e);
    setStatus('Die Bearbeitung kann bis zu ca. 2,5 Minuten dauern', 'error');
  }
}

function displayTextOutputs(outputs) {
  const textDiv = document.getElementById('textOutputs');
  const content = document.getElementById('textOutputsContent');
  content.innerHTML = '';

  const nodes = [];
  for (const [nid, out] of Object.entries(outputs)) {
    if (out.text || out.output || out.response) {
      const orig = originalWorkflow[nid];
      const label = orig._meta?.title || orig.class_type || `Node ${nid}`;
      nodes.push({ nid, label, type: orig.class_type, text: out.text || out.output || out.response });
    }
  }
  if (nodes.length === 0) return;

  for (const n of nodes) {
    const item = document.createElement('div');
    item.className = 'text-output-item';
    const lbl = document.createElement('div');
    lbl.className = 'text-output-label';
    lbl.innerHTML = `${n.label} <span style="font-size:0.8em;color:#888;">(${n.type})</span>`;
    const cnt = document.createElement('div');
    cnt.className = 'text-output-content';
    cnt.textContent = n.text;
    item.appendChild(lbl);
    item.appendChild(cnt);
    content.appendChild(item);
  }
  textDiv.style.display = 'block';
}

function findImageInOutputs(outputs) {
  for (const out of Object.values(outputs)) {
    if (out.images && out.images.length > 0) {
      return out.images[0];
    }
  }
  return null;
}

function displayResultImage(img) {
  const el = document.getElementById('result');
  el.src = `/comfyui/view?filename=${img.filename}&subfolder=${img.subfolder||''}&type=${img.type||'output'}`;
  el.style.display = 'block';
}

function finishPollingSuccess(interval) {
  clearInterval(interval);
  setStatus('Workflow erfolgreich ausgef√ºhrt!', 'success');
  document.getElementById('submitBtn').disabled = false;
  updateProgress(100, 'Fertig!');
  setTimeout(() => {
    hideProgress();
    websocket && websocket.close();
  }, 1000);
}

function finishPollingError(interval, msg) {
  clearInterval(interval);
  setStatus(msg, 'error');
  document.getElementById('submitBtn').disabled = false;
  hideProgress();
  websocket && websocket.close();
}

async function pollResult(promptId) {
  let tries = 0;
  const interval = setInterval(async () => {
    tries++;
    if (tries > MAX_POLLING_TRIES) {
      finishPollingError(interval, 'Verarbeitung dauert vermutlich zu lang - ggf. Auftrag neu starten');
      return;
    }
    try {
      const res = await fetch(`/comfyui/history/${promptId}`);
      if (!res.ok) return;
      const data = await res.json();
      const pd = data[promptId];
      if (pd?.status?.status_str === 'error') {
        const errMsg = pd.status.messages?.join(', ') || 'Unbekannter Fehler';
        finishPollingError(interval, `ComfyUI-Fehler: ${errMsg}`);
        return;
      }
      if (pd?.outputs) {
        displayTextOutputs(pd.outputs);
        const img = findImageInOutputs(pd.outputs);
        if (img) {
          displayResultImage(img);
          finishPollingSuccess(interval);
          return;
        } else if (Object.keys(pd.outputs).length > 0) {
          finishPollingSuccess(interval);
          return;
        }
      }
    } catch (e) {
      console.error('Polling-Fehler:', e);
    }
  }, POLLING_INTERVAL_MS);
}

async function loadWorkflows() {
  const sel = document.getElementById('workflow');
  try {
    setStatus('Lade API-Workflows...', 'info');
    const res = await fetch(`/list_workflows`);
    if (res.ok) {
      const list = await res.json();
      if (list.length > 0) {
        sel.innerHTML = '<option value="">-- Bitte w√§hlen --</option>';
        list.forEach(name => {
          const opt = document.createElement('option');
          opt.value = name;
          opt.textContent = name.replace(/\.json$/, '');
          sel.appendChild(opt);
        });
        setStatus(`${list.length} Workflows geladen`, 'success');
      } else {
        setStatus('Keine API-Workflows gefunden', 'error');
      }
    } else {
      throw new Error('Server nicht erreichbar');
    }
    updateDimensions();
  } catch (e) {
    console.error('Fehler beim Laden der Workflows:', e);
    setStatus('Fehler beim Laden der Workflows', 'error');
  }
}

function generateUUID() {
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
    const r = Math.random() * 16 | 0;
    const v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
}

async function submitPrompt() {
  const workflowName = document.getElementById('workflow').value;
  const promptText = document.getElementById('prompt').value;
  const btn = document.getElementById('submitBtn');
  const resultImg = document.getElementById('result');
  if (!workflowName) {
    setStatus('Bitte w√§hle einen Workflow', 'error');
    return;
  }

  const size = document.getElementById('size').value;
  const aspectRatio = document.getElementById('aspectRatio').value;
  const dims = calculateDimensions(size, aspectRatio);

  try {
    btn.disabled = true;
    resultImg.style.display = 'none';
    document.getElementById('textOutputs').style.display = 'none';
    hideProgress();
    setStatus('Lade Workflow...', 'info');

    const res = await fetch(`/get_workflow/${workflowName}`);
    if (!res.ok) throw new Error('Workflow konnte nicht geladen werden');
    const wf = await res.json();
    originalWorkflow = wf;

    // Prompt in die Node mit class_type "PrimitiveString" und Titel "ai4artsed_text_prompt" injizieren
    for (const [nid, node] of Object.entries(wf)) {
      if (node.class_type === "PrimitiveString" && node._meta?.title === "ai4artsed_text_prompt") {
        node.inputs.value = promptText;
        break;
      }
    }

    // Zuf√§lligen Seed setzen bei KSampler-Nodes
    for (const node of Object.values(wf)) {
      if (node.class_type === "KSampler") {
        node.inputs.seed = Math.floor(Math.random() * 1e9);
      }
    }

    // Dimensionen setzen bei EmptyLatentImage-Nodes
    for (const node of Object.values(wf)) {
      if (node.class_type === "EmptyLatentImage") {
        node.inputs.width = dims.width;
        node.inputs.height = dims.height;
      }
    }

    setStatus('Sende an ComfyUI...', 'info');
    const clientId = generateUUID();
    setupWebSocket(clientId);

    const post = await fetch(`/comfyui/prompt`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ prompt: wf, client_id: clientId })
    });
    if (!post.ok) {
      const errText = await post.text();
      throw new Error(`ComfyUI-Fehler: ${errText}`);
    }
    const data = await post.json();
    currentPromptId = data.prompt_id;
    if (!currentPromptId) throw new Error('Keine prompt_id erhalten');

    setStatus('Verarbeite Workflow...', 'info');
    pollResult(currentPromptId);
  } catch (e) {
    setStatus(`Fehler: ${e.message}`, 'error');
    console.error(e);
    btn.disabled = false;
    hideProgress();
    websocket && websocket.close();
  }
}

window.addEventListener('load', loadWorkflows);
</script>
</body>
</html>

