
# Zentrierte, geräteunabhängige Bubble-Layouts in Vue

## 1. Problemdefinition

Die Screenshots zeigen ein „Bubble-Cluster“:

- mehrere kreisförmige Cards („Konfigurationen“),
- in einer frei angeordneten, leicht radialen Komposition,
- die **als Gesamtcluster in der Mitte des Viewports** erscheinen soll,
- mit konsistenter Darstellung auf Desktop und iPad (insb. iPad Pro quer).

Technisch sind drei Ebenen zu unterscheiden:

1. **Zentrierung des Clusters im Viewport** – rein ein Layoutproblem (Flexbox/Grid).
2. **Geometrie der Bubbles innerhalb des Clusters** – Kreisgrößen und Positionen.
3. **Vue-Integration** – reactive Datenbindung, eventuelle Resize-Logik.

Vue selbst kümmert sich nicht um Layout; das geschieht über CSS (Flexbox/Grid, `aspect-ratio`, `vw`/`vh` etc.). Vue liefert lediglich Struktur, State und dynamische Klassen/Styles. :contentReference[oaicite:0]{index=0}  

---

## 2. Zentrierung des Clusters im Viewport

### 2.1 Flexbox als robustes Pattern

Aktuelle Guides empfehlen Flexbox als Standard, um ein einzelnes Element sowohl horizontal als auch vertikal zu zentrieren. :contentReference[oaicite:1]{index=1}  

Pattern:

```css
html,
body,
#app {
  height: 100%;
  margin: 0;
}

.app-root {
  display: flex;
  align-items: center;   /* vertikal */
  justify-content: center; /* horizontal */
  min-height: 100vh;       /* inkl. iPad, Desktop */
  background: #000;        /* Beispiel */
}
````

In Vue:

```html
<!-- App.vue -->
<template>
  <main class="app-root">
    <BubbleCluster />
  </main>
</template>
```

Vorteile:

* **Geräteagnostisch:** Flexbox kümmert sich automatisch um Zentrierung unabhängig von Viewportgröße. ([programiz.com][1])
* Kein JS notwendig (wichtig für Stabilität auf iPad Safari).
* Gut kombinierbar mit Safe-Area-Insets (`padding: env(safe-area-inset-*)`) falls nötig.

### 2.2 Alternative: CSS Grid

Grid kann ein einzelnes Element ebenfalls trivial zentrieren (z. B. `place-items: center`). ([paulund.co.uk][2])

```css
.app-root {
  display: grid;
  place-items: center; /* horizontale + vertikale Zentrierung */
  min-height: 100vh;
}
```

**Empfehlung:** Für Ihren Anwendungsfall (ein zentraler Cluster) ist Flexbox minimal-invasiv und ausreichend; Grid lohnt sich eher, wenn Sie später zusätzliche Zonen (Sidebar, Footer etc.) definieren möchten.

---

## 3. Das Bubble-Cluster: responsive Geometrie

### 3.1 Prinzip: quadratischer, skalierender Cluster-Container

Statt die Bubbles direkt relativ zum Viewport zu positionieren, wird ein **quadratischer Container** zentriert, in dem alle Bubbles als `position: absolute` liegen.

```css
.cluster-wrapper {
  position: relative;
  width: min(70vw, 70vh);   /* begrenzt durch kleinere Kante */
  aspect-ratio: 1 / 1;      /* garantiert Quadrat */
}
```

* `min(70vw, 70vh)` sorgt dafür, dass der Cluster **proportional** skaliert, ohne auf schmalen Screens zu kollidieren.
* `aspect-ratio` (heute breit unterstützt) erhält die Kreisgeometrie unabhängig von der Bildschirmform. ([paulund.co.uk][2])

Damit ist das Cluster auf iPad, Laptop, Desktop usw. visuell identisch skaliert.

### 3.2 Bubbles als prozentuale Positionen

Für statische Layouts (z. B. 4–6 Bubbles mit vordefinierter Komposition) genügt **reines CSS mit Prozentangaben**. Für responsive Kreise wird in hochwertigen Beispielen empfohlen, von „quadratischen Boxes“ auszugehen und mittels `border-radius: 50%` Kreise zu erzeugen. ([Stack Overflow][3])

```css
.bubble {
  position: absolute;
  border-radius: 50%;
  overflow: hidden;
}

/* Beispiel: eine große Haupt-Bubble */
.bubble--main {
  width: 45%;
  height: 45%;
  top: 5%;
  left: 30%;
}

/* kleinere Satelliten */
.bubble--left {
  width: 32%;
  height: 32%;
  top: 40%;
  left: 5%;
}

.bubble--right {
  width: 32%;
  height: 32%;
  top: 45%;
  left: 63%;
}

/* usw. */
```

Weil alle Größen und Positionen in Prozent des quadratischen Containers definiert sind, bleibt:

* das Verhältnis der Bubbles zueinander konstant,
* das gesamte Cluster skaliert sauber mit, ohne Media Queries.

### 3.3 Wenn die Anzahl der Bubbles variiert

Falls die Anzahl dynamisch ist (z. B. 3–8 Konfigurationen), gibt es zwei Strategien:

1. **Vorlagen („Layouts“) pro Anzahl**
   Für `n=3,4,5,6,...` wird je ein Satz von Prozentkoordinaten vordefiniert. Das ist geometrisch kontrollierbar und stabil, insbesondere für ästhetische, leicht unregelmäßige Kompositionen (wie in Ihren Screenshots).

2. **Algorithmische Positionierung (z. B. einfacher Kreis)**
   Bei vielen Items können Sie Positionen per Polar-Koordinaten generieren. Schöne, aber weniger „kuratiert“ wirkende Layouts.

---

## 4. Vue-spezifische Integration

### 4.1 Komponentenstruktur

Ein möglicher Aufbau:

```text
App.vue          -> zentriert BubbleCluster im Viewport
BubbleCluster.vue
  |- erhält Liste von Konfigurationen
  |- berechnet für jede Bubble: Größe, Position, Zustände (hover/active)
  |- rendert Bubbles mit dynamischen Styles
```

### 4.2 Datengetriebene Styles über `v-bind:style`

Die offizielle Vue-Dokumentation empfiehlt für dynamische Positionierung die Verwendung von Objekt-Syntax in `:style` und `:class`. ([vuejs.org][4])

Beispiel:

```vue
<!-- BubbleCluster.vue -->
<template>
  <section class="cluster-wrapper">
    <article
      v-for="bubble in bubbles"
      :key="bubble.id"
      class="bubble"
      :class="bubble.variant"
      :style="bubbleStyle(bubble)"
      @click="select(bubble)"
    >
      <!-- Inhalt / Bild / Label -->
    </article>
  </section>
</template>

<script setup>
const props = defineProps({
  bubbles: {
    type: Array,
    required: true,
    // Each bubble: { id, x, y, size, variant, ... }
  },
})

const bubbleStyle = bubble => ({
  width: `${bubble.size}%`,
  height: `${bubble.size}%`,
  top: `${bubble.y}%`,
  left: `${bubble.x}%`,
})
</script>
```

`x, y, size` sind hier **normierte Prozentwerte** (0–100), die entweder vordefiniert oder algorithmisch erzeugt werden.

### 4.3 Responsives Verhalten & Breakpoints in Vue

Für das Layout selbst sollten Sie **primär CSS** nutzen. Vue kommt erst ins Spiel, wenn:

* bei bestimmten Breakpoints andere Layoutvarianten gewählt werden sollen,
* Inhalte je nach Gerätebreite wechseln (z. B. andere Labels).

Best-Practice-Artikel zu Vue und responsive Design betonen:

* **mobile-first CSS** mit Flexbox/Grid,
* optional reaktive Breakpoints im Composition API, um Template-Pfade zu wechseln. ([Borstch][5])

---

## 5. Resize-bezogene Logik (optional)

Solange Sie rein mit Prozentangaben arbeiten, benötigen Sie keine JS-Resize-Logik. Falls Sie jedoch:

* Bubbles abhängig von **realen Pixelmaßen** des Containers dimensionieren,
* oder bei bestimmten Dimensionen in ein alternativ arrangiertes Layout wechseln möchten,

dann bietet sich `ResizeObserver` an. Aktuelle Tutorials zeigen, wie damit Layout-Anpassungen an Containergrößen statt an Window-Events geknüpft werden können. ([LogRocket Blog][6])

Skizze im Composition API:

```ts
import { ref, onMounted, onBeforeUnmount } from 'vue'

const clusterRef = ref<HTMLElement | null>(null)
const size = ref({ width: 0, height: 0 })

let observer: ResizeObserver | null = null

onMounted(() => {
  if (!clusterRef.value) return

  observer = new ResizeObserver(entries => {
    for (const entry of entries) {
      const { width, height } = entry.contentRect
      size.value = { width, height }
      // hier ggf. Positions-/Größenlogik anstoßen
    }
  })

  observer.observe(clusterRef.value)
})

onBeforeUnmount(() => {
  observer?.disconnect()
})
```

Im Template:

```vue
<section ref="clusterRef" class="cluster-wrapper">
  <!-- Bubbles -->
</section>
```

---

## 6. Beispiel einer vollständigen, geräteagnostischen Implementierung

### 6.1 Template

```vue
<!-- BubbleCluster.vue -->
<template>
  <section class="cluster-wrapper">
    <article
      v-for="bubble in layout"
      :key="bubble.id"
      class="bubble"
      :class="['bubble--' + bubble.role]"
      :style="bubbleStyle(bubble)"
      @click="$emit('select', bubble.id)"
    >
      <img :src="bubble.image" alt="" class="bubble__image" />
      <footer class="bubble__label">{{ bubble.label }}</footer>
    </article>
  </section>
</template>
```

### 6.2 Script

```ts
<script setup lang="ts">
interface BubbleLayout {
  id: string
  role: 'main' | 'secondary' | 'tertiary'
  x: number // 0–100
  y: number // 0–100
  size: number // Prozent der Containerbreite
  label: string
  image: string
}

const props = defineProps<{
  layout: BubbleLayout[]
}>()

const bubbleStyle = (b: BubbleLayout) => ({
  width: `${b.size}%`,
  height: `${b.size}%`,
  top: `${b.y}%`,
  left: `${b.x}%`,
})
</script>
```

Die `layout`-Daten können pro Screen aus einer Konfiguration kommen, z. B.:

```ts
export const fourConfigLayout: BubbleLayout[] = [
  { id: 'technisch', role: 'main', x: 32, y: 5, size: 46, ... },
  { id: 'uebertreiber', role: 'secondary', x: 5, y: 38, size: 33, ... },
  { id: 'maerchen', role: 'secondary', x: 60, y: 42, size: 33, ... },
  { id: 'entkitscher', role: 'tertiary', x: 50, y: 65, size: 26, ... },
]
```

Damit wird das Layout völlig unabhängig von Viewportmaßen, nur über den `cluster-wrapper` skaliert.

### 6.3 Styles

```css
/* App.vue oder global */
html,
body,
#app {
  height: 100%;
  margin: 0;
}

.app-root {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background-color: #050505;
}

/* Cluster */

.cluster-wrapper {
  position: relative;
  width: min(70vw, 70vh);
  aspect-ratio: 1 / 1;
}

/* generische Bubble-Basis */

.bubble {
  position: absolute;
  border-radius: 50%;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  box-shadow: 0 0 40px rgba(0, 0, 0, 0.6);
  cursor: pointer;
  transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
}

.bubble__image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.bubble__label {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  padding: 0.3rem 0.75rem;
  font-size: clamp(0.7rem, 0.9vw, 0.9rem);
  color: #fff;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
}

/* Rollen für visuelle Gewichtung */

.bubble--main {
  z-index: 3;
}

.bubble--secondary {
  z-index: 2;
}

.bubble--tertiary {
  z-index: 1;
}

/* Hover/Focus – auf Touch-Geräten nur Klickrelevant */

.bubble:hover,
.bubble:focus-visible {
  transform: scale(1.04);
  box-shadow: 0 0 60px rgba(255, 255, 255, 0.2);
}
```

Dieses Setup erfüllt:

* **Zentrierung** des Clusters über den gesamten Viewport,
* **Geräteunabhängigkeit** durch prozentuale Koordinaten und `min(vw, vh)`-Skalierung,
* klare Trennung zwischen **Layout (CSS)** und **Logik (Vue)**.

---

## 7. Spezifische Hinweise für iPad Pro (quer)

Für iPad Pro 10" quer ist primär wichtig:

1. **`min-height: 100vh` statt fester Pixelwerte** – verhindert, dass UI im Safari-Viewport „klebt“, wenn Browser-UI ein-/ausblendet. ([paulund.co.uk][2])
2. **Keine Fixed-Positionierung für das Cluster**, sondern Flexbox-Zentrierung (vermeidet Notches/Toolbar-Probleme).
3. Falls nötig: `padding: env(safe-area-inset-top)` etc. auf der Root-Container-Ebene.

---

## 8. Kurzfassung der Empfehlungen

1. **Verwenden Sie auf oberster Ebene Flexbox, um das Cluster zu zentrieren.**
2. **Legen Sie einen quadratischen `cluster-wrapper` mit `width: min(vw, vh)` und `aspect-ratio: 1/1` an.**
3. **Positionieren Sie Bubbles innerhalb des Wrappers mit Prozentangaben für `top`, `left`, `width`, `height`.**
4. **Halten Sie Geometrie als Daten (`layout[]`) in Vue und setzen Sie sie via `:style` um.**
5. **Nutzen Sie bei Bedarf `ResizeObserver` und reaktive Breakpoints nur für alternative Layoutvarianten, nicht für die Basiszentrierung.**

Damit sollten sich die von Claude generierten Layout-Probleme zuverlässig eliminieren lassen, und das Interface bleibt über Desktop, iPad Pro und andere Endgeräte hinweg stabil und gut kontrollierbar.

```
```

[1]: https://www.programiz.com/css/responsive-layout-using-css-flex?utm_source=chatgpt.com "Responsive Layout Using CSS Flex (With Examples) - Programiz"
[2]: https://paulund.co.uk/css-layout-responsive-design-guide?utm_source=chatgpt.com "Complete CSS Layout and Responsive Design Guide | Paulund"
[3]: https://stackoverflow.com/questions/46780591/how-to-have-a-perfect-responsive-css-circles?utm_source=chatgpt.com "flexbox - how to have a perfect responsive css circles? - Stack Overflow"
[4]: https://vuejs.org/guide/essentials/class-and-style.html?utm_source=chatgpt.com "Class and Style Bindings - Vue.js"
[5]: https://borstch.com/snippet/responsive-design-with-vue-3-composition-api?utm_source=chatgpt.com "Responsive Design with Vue 3 Composition API - Borstch"
[6]: https://blog.logrocket.com/how-to-use-the-resizeobserver-api-a-tutorial-with-examples/?utm_source=chatgpt.com "The ResizeObserver API: A tutorial with examples"

